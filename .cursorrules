# Claude Marketplace - Cursor AI Rules

You are working on a repository that hosts **Claude Code plugins** for plugin development and advanced engineering workflows.

## Core Architecture

### Plugin Types in This Repository

1. **`cc/plugin-builder`** - Meta-plugin for building Claude Code plugins

   - Interactive commands: `/new-plugin`, `/new-command`, `/new-agent`
   - Comprehensive guides in `cc/skills/claude-code-plugin-builder/`
   - Production templates in `cc/skills/claude-code-plugin-builder/templates/`

2. **`exito/`** - Senior engineer workflow plugin

   - Multi-agent PR review system
   - Systematic development workflow with 7-phase process
   - 8 specialized subagents in `exito/agents/`
   - Session-based state management via hooks

3. **`setup/`** - Installation commands for CLI tools and MCP servers

## Plugin Structure Pattern

ALL plugins in this repository follow this structure:

```
plugin-name/
├── .claude-plugin/
│   └── plugin.json          # Required manifest
├── commands/                 # User-facing slash commands
│   └── command-name.md      # YAML frontmatter + instructions
├── agents/                   # Specialized subagents
│   └── agent-name.md        # YAML frontmatter + role definition
├── skills/                   # Optional: Agent Skills
│   └── skill-name/
│       └── SKILL.md
└── hooks/                    # Optional: Event-driven automation
    └── hooks.json
```

## File Format Standards

### Command Files (commands/\*.md)

```markdown
---
description: "What this command does (user sees in /help)"
argument-hint: "<REQUIRED> [OPTIONAL]"
allowed-tools: Read, Write, Bash(gh:*)
model: claude-sonnet-4-5-20250929
---

# Command Instructions

- Use $1, $2 for arguments
- Use $ARGUMENTS for all args
- Use !`command` for bash execution embedded in context
- Use Task tool for agent invocations
```

### Agent Files (agents/\*.md)

```markdown
---
name: agent-identifier
description: "When to invoke this agent"
tools: Read, Write
model: claude-sonnet-4-5-20250929
---

<role>
You are [identity]. Your expertise is [domain].
</role>

<input>
- `$1`: Argument description
</input>

<workflow>
Step-by-step process...
</workflow>

<output_format>
Expected structure...
</output_format>
```

**Critical Agent Rules:**

- Agents run in isolated contexts (no conversation history)
- Agents have clean state (cwd resets to project root)
- Agents must explicitly request tools in frontmatter
- Always specify model explicitly in agent frontmatter

## Multi-Agent Orchestration

### File-Based Context Sharing (PRIMARY PATTERN)

**❌ NEVER:**

```markdown
<Task agent="analyzer">
[10,000 lines of code here]
</Task>
```

**✅ ALWAYS:**

```markdown
# Phase 1: Create context

<Task agent="context-gatherer">
  Analyze PR $1. Save to: .claude/sessions/pr_reviews/pr_123_context.md
</Task>

# Phase 2: Parallel analysis (in SINGLE message)

<Task agent="performance-analyzer">
  Read context from: .claude/sessions/pr_reviews/pr_123_context.md
  Write report to: .claude/sessions/pr_reviews/pr_123_performance.md
</Task>
<Task agent="security-scanner">
  Read context from: .claude/sessions/pr_reviews/pr_123_context.md
  Write report to: .claude/sessions/pr_reviews/pr_123_security.md
</Task>

# Phase 3: Synthesize

Read all reports from .claude/sessions/pr*reviews/pr_123*\*.md
```

**Benefits:** 60-70% token reduction, enables parallelism, creates audit trail

### Session Management Pattern

- Session ID available via `$CLAUDE_SESSION_ID`
- Session directory: `.claude/sessions/tasks/$CLAUDE_SESSION_ID/`
- `PreToolUse` hook initializes session directory
- `SessionEnd` hook performs cleanup
- See `exito/hooks/hooks.json` and `exito/scripts/session-manager.sh`

## Development Best Practices

### SOLID Principles

- **Single Responsibility:** Keep route files focused on one purpose
- **Open/Closed:** Extend routes without modifying existing ones
- **Liskov Substitution:** Maintain consistent route behavior
- **Interface Segregation:** Use smaller, focused hooks and components
- **Dependency Inversion:** Inject dependencies via router context

### DRY (Don't Repeat Yourself)

- Extract common route logic into shared utility functions
- Create reusable layout routes for consistent UI patterns
- Use route context to share data and functionality

### KISS (Keep It Simple)

- Avoid overly complex route hierarchies
- Prefer declarative route definitions over imperative code
- Use standard patterns consistently across the application

### Clean Code

- Use descriptive names for route files and components
- Document complex routing scenarios with comments
- Create meaningful error messages for routing issues
- Properly type and validate all route parameters

## Critical Workflows

### /workflow Command Pattern (7-Phase Systematic Development)

1. **Discover** - Deep context gathering (investigator agent)
2. **Validate** - Check information completeness (requirements-validator)
3. **Explore** - Generate 2-4 alternatives (solution-explorer)
4. **Select** - User chooses approach (interactive pause)
5. **Plan** - Detailed implementation (architect agent with extended thinking)
6. **Approve** - User reviews plan (interactive pause)
7. **Execute** - Surgical implementation (surgical-builder agent)
8. **Test** - Comprehensive validation
9. **Review** - Quality assurance
10. **Document** - Knowledge base creation

**Key:** Wait for user input at Select and Approve phases. Document interactive pauses with clear prompts.

### /review Command Pattern (Multi-Agent PR Review)

1. **Context Establishment** - Platform-agnostic PR data normalization
2. **Business Validation** - Optional Azure DevOps User Story alignment
3. **Parallel Analysis** - 6 specialized agents run simultaneously
4. **Synthesis** - Unified final report with scores and action plan

**Platform Detection:** Context-gatherer auto-detects GitHub (via `gh` CLI) or Azure DevOps (via Azure MCP)

## Best Practices from This Codebase

1. **Extended Thinking for Complex Tasks**

   - Use `think`, `think hard`, `think harder`, or `ULTRATHINK` based on complexity
   - See `exito/agents/architect.md` for examples

2. **Token Efficiency**

   - File paths > content passing
   - Achieves 60-70% token reduction
   - See `cc/skills/claude-code-plugin-builder/WORKFLOWS.md`

3. **Structured Prompts**

   - Use XML tags: `<role>`, `<workflow>`, `<output_format>`, `<input>`
   - Clear separation of concerns
   - Improves agent understanding and consistency

4. **Graceful Degradation**

   - Validate inputs before processing
   - Handle missing data with fallbacks
   - Provide helpful error messages

5. **Actionable Output**

   - Every finding includes: location, description, impact, fix example, priority
   - Make reports immediately actionable
   - No vague recommendations

6. **Session Isolation**

   - Use hooks for automatic session lifecycle management
   - Clean up after tasks complete
   - Maintain audit trails

7. **Platform Agnostic Design**
   - Normalize data from multiple sources
   - See `exito/agents/context-gatherer.md` for patterns

## Common Pitfalls to AVOID

1. ❌ **Don't duplicate context** - Use file paths, not content, between agents
2. ❌ **Don't inherit models blindly** - Explicitly specify model in agent frontmatter
3. ❌ **Don't forget interactive pauses** - Workflow command has explicit user decision points
4. ❌ **Don't skip validation** - Check session environment before proceeding
5. ❌ **Don't use sequential invocations for parallel work** - Multiple `<Task>` calls in one message enable true parallelism

## Key Documentation References

When working on this codebase, reference these files:

- `exito/commands/workflow.md` - Full systematic workflow pattern
- `exito/commands/review.md` - Parallel multi-agent orchestration
- `cc/skills/claude-code-plugin-builder/AGENTS.md` - Comprehensive agent design guide (977 lines)
- `cc/skills/claude-code-plugin-builder/WORKFLOWS.md` - Token optimization patterns
- `cc/skills/claude-code-plugin-builder/COMMANDS.md` - Slash command patterns
- `cc/skills/claude-code-plugin-builder/HOOKS.md` - Event-driven automation
- `cc/skills/claude-code-plugin-builder/MCP.md` - External tool integration
- `exito/agents/architect.md` - Extended thinking and session validation patterns
- `cc/QUICKREF.md` - Fast syntax reference (630 lines)
- `docs/claude-code-docs/` - Official Claude Code feature documentation

## Testing Changes

```bash
# Add local marketplace
/plugin marketplace add ./claude-marketplace

# Install plugin
/plugin install plugin-builder@local
/plugin install exito@local

# Test commands
/new-plugin
/review <PR_URL>
/workflow "Add feature X"
```

## When Editing Files

### Adding New Commands

1. Create markdown file in appropriate `commands/` directory
2. Use YAML frontmatter with description and argument-hint
3. Follow command file format standard
4. Test with local plugin installation

### Adding New Agents

1. Create markdown file in appropriate `agents/` directory
2. Use YAML frontmatter with name, description, tools, and model
3. Structure with `<role>`, `<input>`, `<workflow>`, `<output_format>` tags
4. Remember: agents are isolated, specify all requirements explicitly

### Modifying Orchestration

1. Prefer file-based context sharing over content passing
2. Group parallel agent invocations in single message
3. Use session directories for intermediate artifacts
4. Document phase transitions clearly

### Adding Hooks

1. Add to `hooks/hooks.json` in plugin directory
2. Use matchers to target specific events
3. Ensure scripts are executable and handle errors
4. Test session lifecycle (start, middle, end)

## Output Standards

When generating code or documentation:

- Use clear, descriptive names
- Include inline comments for complex logic
- Follow existing patterns in the codebase
- Validate all inputs
- Provide actionable error messages
- Structure output with XML tags for agents
- Use markdown for command instructions
