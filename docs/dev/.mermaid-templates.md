# Mermaid Diagram Templates for Architect Agent

This file provides reference templates that the architect agent can use when creating visual architecture diagrams.

## System Architecture Diagrams

### Basic Component Relationship (graph TD)
```mermaid
graph TD
    A[Component A] -->|uses| B[Component B]
    A -->|depends on| C[Component C]
    B --> D[Component D]
    C --> D
```

### Layered Architecture
```mermaid
graph TD
    UI[UI Layer] --> BL[Business Logic Layer]
    BL --> DAL[Data Access Layer]
    DAL --> DB[(Database)]

    UI --> Cache[Cache Layer]
    BL --> Cache
```

### Microservices Architecture
```mermaid
graph TD
    Client[Client App] --> Gateway[API Gateway]
    Gateway --> Auth[Auth Service]
    Gateway --> User[User Service]
    Gateway --> Order[Order Service]

    User --> UserDB[(User DB)]
    Order --> OrderDB[(Order DB)]
    Auth --> Cache[(Redis Cache)]
```

### Plugin Architecture
```mermaid
graph TD
    Core[Core System] --> PluginA[Plugin A]
    Core --> PluginB[Plugin B]
    Core --> PluginC[Plugin C]

    Core --> API[Plugin API]
    PluginA -.implements.-> API
    PluginB -.implements.-> API
    PluginC -.implements.-> API
```

## Data Flow Diagrams (sequenceDiagram)

### User Authentication Flow
```mermaid
sequenceDiagram
    participant User
    participant Frontend
    participant API
    participant Auth
    participant DB

    User->>Frontend: Enter credentials
    Frontend->>API: POST /login
    API->>Auth: Validate credentials
    Auth->>DB: Query user
    DB-->>Auth: User data
    Auth-->>API: Token
    API-->>Frontend: JWT token
    Frontend-->>User: Redirect to dashboard
```

### Data Processing Pipeline
```mermaid
sequenceDiagram
    participant Client
    participant Queue
    participant Worker
    participant Storage
    participant Notification

    Client->>Queue: Submit job
    Queue-->>Client: Job ID
    Worker->>Queue: Poll for jobs
    Queue-->>Worker: Job data
    Worker->>Storage: Process & save
    Storage-->>Worker: Success
    Worker->>Notification: Send completion
    Notification-->>Client: Job complete
```

### API Request Flow
```mermaid
sequenceDiagram
    participant Client
    participant Gateway
    participant Service
    participant Cache
    participant Database

    Client->>Gateway: GET /api/data
    Gateway->>Cache: Check cache
    alt Cache hit
        Cache-->>Gateway: Cached data
        Gateway-->>Client: Return data
    else Cache miss
        Gateway->>Service: Forward request
        Service->>Database: Query data
        Database-->>Service: Data
        Service->>Cache: Store in cache
        Service-->>Gateway: Data
        Gateway-->>Client: Return data
    end
```

## Component Structure (classDiagram)

### Data Model Relationships
```mermaid
classDiagram
    class User {
        +id: string
        +name: string
        +email: string
        +getPosts()
        +getComments()
    }

    class Post {
        +id: string
        +title: string
        +content: string
        +authorId: string
        +getAuthor()
        +getComments()
    }

    class Comment {
        +id: string
        +content: string
        +postId: string
        +authorId: string
        +getPost()
        +getAuthor()
    }

    User "1" --> "*" Post : writes
    User "1" --> "*" Comment : writes
    Post "1" --> "*" Comment : has
```

### Service Dependencies
```mermaid
classDiagram
    class UserService {
        -repository: UserRepository
        -validator: Validator
        +createUser()
        +getUser()
        +updateUser()
    }

    class UserRepository {
        -db: Database
        +save()
        +findById()
        +findByEmail()
    }

    class Validator {
        +validateEmail()
        +validatePassword()
    }

    class Database {
        +query()
        +execute()
    }

    UserService --> UserRepository
    UserService --> Validator
    UserRepository --> Database
```

### Interface Implementation
```mermaid
classDiagram
    class IStorage {
        <<interface>>
        +save(data)
        +load(key)
        +delete(key)
    }

    class LocalStorage {
        +save(data)
        +load(key)
        +delete(key)
    }

    class CloudStorage {
        -apiKey: string
        +save(data)
        +load(key)
        +delete(key)
    }

    class DatabaseStorage {
        -connection: Connection
        +save(data)
        +load(key)
        +delete(key)
    }

    IStorage <|.. LocalStorage : implements
    IStorage <|.. CloudStorage : implements
    IStorage <|.. DatabaseStorage : implements
```

## State Management Flow (graph LR)

### React State Flow
```mermaid
graph LR
    Action[User Action] --> Dispatch[Dispatch Action]
    Dispatch --> Reducer[Reducer]
    Reducer --> Store[Update Store]
    Store --> Component[Re-render Components]
    Component --> UI[Update UI]
```

### Event-Driven Architecture
```mermaid
graph LR
    Event[Event Occurs] --> Bus[Event Bus]
    Bus --> L1[Listener 1]
    Bus --> L2[Listener 2]
    Bus --> L3[Listener 3]
    L1 --> A1[Action 1]
    L2 --> A2[Action 2]
    L3 --> A3[Action 3]
```

## Frontend Component Hierarchy

### React Component Tree
```mermaid
graph TD
    App[App] --> Router[Router]
    Router --> Layout[Layout]
    Layout --> Header[Header]
    Layout --> Sidebar[Sidebar]
    Layout --> MainContent[Main Content]

    Header --> Nav[Navigation]
    Header --> UserMenu[User Menu]

    MainContent --> Dashboard[Dashboard]
    Dashboard --> Widgets[Widgets Container]
    Widgets --> Widget1[Widget 1]
    Widgets --> Widget2[Widget 2]
    Widgets --> Widget3[Widget 3]
```

### Component Data Flow
```mermaid
graph TD
    Store[(Global Store)] --> App[App Component]
    App --> Context[Context Provider]
    Context --> Parent[Parent Component]
    Parent --> ChildA[Child A]
    Parent --> ChildB[Child B]

    ChildA -.callback.-> Parent
    ChildB -.callback.-> Parent
    Parent -.dispatch.-> Store
```

## Deployment Architecture

### Multi-Environment Setup
```mermaid
graph TD
    Repo[Git Repository] --> CI[CI/CD Pipeline]
    CI --> Dev[Dev Environment]
    CI --> Stage[Staging Environment]
    CI --> Prod[Production Environment]

    Dev --> DevDB[(Dev Database)]
    Stage --> StageDB[(Staging Database)]
    Prod --> ProdDB[(Production Database)]
```

### Container Architecture
```mermaid
graph TD
    LB[Load Balancer] --> Container1[Container 1]
    LB --> Container2[Container 2]
    LB --> Container3[Container 3]

    Container1 --> SharedDB[(Shared Database)]
    Container2 --> SharedDB
    Container3 --> SharedDB

    Container1 --> Cache[(Redis Cache)]
    Container2 --> Cache
    Container3 --> Cache
```

## When to Use Which Diagram Type

### graph TD (Top-Down Graph)
- **Use for**: Component relationships, hierarchies, system architecture
- **Best when**: Showing how parts relate to each other
- **Direction**: `TD` (top-down), `LR` (left-right), `RL` (right-left), `BT` (bottom-top)

### sequenceDiagram
- **Use for**: Time-based interactions, API flows, user journeys
- **Best when**: Showing order of operations and communication between actors
- **Key feature**: Shows temporal sequence of events

### classDiagram
- **Use for**: Data models, object relationships, interface definitions
- **Best when**: Showing structure and relationships of classes/objects
- **Key feature**: Shows inheritance, composition, and associations

### graph LR (Left-Right Graph)
- **Use for**: Process flows, pipelines, state transitions
- **Best when**: Showing linear or branching processes
- **Key feature**: Horizontal flow is easier to read for sequential processes

## Tips for Effective Diagrams

1. **Keep it simple**: 5-10 nodes max per diagram
2. **Use clear labels**: Describe relationships with verbs
3. **Group related concepts**: Use subgraphs if needed
4. **Choose appropriate direction**: TD for hierarchy, LR for flow
5. **Add context**: Brief description above each diagram
6. **One concept per diagram**: Don't try to show everything
7. **Use consistent naming**: Match code/file names when possible
8. **Color sparingly**: Only to highlight critical paths (if supported)

## Example: Complete Architecture Plan with Multiple Diagrams

### System Overview
```mermaid
graph TD
    Client[Web Client] --> API[API Gateway]
    API --> Auth[Auth Service]
    API --> Business[Business Logic]
    Business --> Data[Data Layer]
    Data --> DB[(Database)]
```

### Request Flow Detail
```mermaid
sequenceDiagram
    participant Client
    participant API
    participant Auth
    participant Service
    participant DB

    Client->>API: Request with token
    API->>Auth: Validate token
    Auth-->>API: Valid
    API->>Service: Process request
    Service->>DB: Query
    DB-->>Service: Data
    Service-->>API: Response
    API-->>Client: JSON response
```

### Data Model
```mermaid
classDiagram
    class User {
        +id: UUID
        +email: string
        +createdAt: Date
    }
    class Session {
        +id: UUID
        +userId: UUID
        +token: string
        +expiresAt: Date
    }
    User "1" --> "*" Session
```

This combination gives a complete picture: structure (graph), behavior (sequence), and data (class).
